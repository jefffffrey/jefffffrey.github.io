{"meta":{"title":"Jeffrey's Blog","subtitle":"Live and learn!","description":null,"author":"Jeffrey Teo","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-10-28T10:43:33.000Z","updated":"2017-10-28T10:43:33.252Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"MySQL存储过程及函数核心知识点","slug":"MySQL存储过程及函数核心知识点","date":"2017-10-31T13:34:33.000Z","updated":"2017-10-31T13:45:35.551Z","comments":true,"path":"2017/10/31/MySQL存储过程及函数核心知识点/","link":"","permalink":"http://yoursite.com/2017/10/31/MySQL存储过程及函数核心知识点/","excerpt":"","text":"本文记录了MySQL存储过程的一些核心知识点，详细内容请参考官方文档。文中的MySQL版本为5.7。 语法CREATE [DEFINER = &#123; user | CURRENT_USER &#125;] PROCEDURE sp_name ([proc_parameter[,...]]) [characteristic ...] routine_bodyCREATE [DEFINER = &#123; user | CURRENT_USER &#125;] FUNCTION sp_name ([func_parameter[,...]]) RETURNS type [characteristic ...] routine_bodyproc_parameter: [ IN | OUT | INOUT ] param_name typefunc_parameter: param_name typetype: Any valid MySQL data typecharacteristic: COMMENT &apos;string&apos; | LANGUAGE SQL | [NOT] DETERMINISTIC | &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125; | SQL SECURITY &#123; DEFINER | INVOKER &#125;routine_body: Valid SQL routine statement 存储过程可以加 db_name限定数据库，不加就使用默认数据库 默认情况下，MYSQL给 proc_parameter默认IN，可以选择OUT，INOUT proc_parameter只支持IN characteristic COMMENT用于写备注 LANGUAGE这个server被忽略，只是为了符合SQL标准 DETERMINISTIC和NOT DETERMINISTIC。这个只是创建者自己定义的，MYSQL不会做任何检查。但是如果把NOT DETEMINISTIC定义为DETERMINISTIC，可能导致优化器做出错误的执行计划。相反，把DETEMINISTIC定义为NOT DETERMINISTIC可能让一些可用的优化措施无法使用。如果使用binary logging，需要参考Binary Logging of Stored Programs. { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }这组被server忽略 SQL SECURITY定义谁可以调用。DEFINER表示由DEFINER属性所指定的用户的权限来执行，INVOKER表示以调用这个存储过程的用户的权限来执行。默认DEFINER，且值为CURRENT_USER。如果用户没有过程中需要的权限，那么INVOKER类型过程的就无法调用。 routine_body可以执行Compound-Statement.以及DDL语句，同时存储过程支持事务。 Compiund StatementBEGIN END语法语句块，可嵌套，可结合Lable使用。 Label语法可用于标记BEGIN，LOOP，REPEAT以及WHILE语句。可以用ITERATE和LEAVE指令控制流程。 DECLARE语法声明变量，条件处理或者游标。限制如下： 只能在BEGIN语句中，且必须在最前面 必须按照变量，游标，条件处理的顺序声明。 变量所用DECLARE声明，赋值可以使用SET语法，SELECT ... INTO var_list 或者 FETCH ... INTO var_list 定义格式： DECLARE var_name [, var_name] ... type [DEFAULT value] 控制流程和C语言的类比 MYSQL C 备注 CASE switch IF if LOOP while(1){} 用ITERATE模拟continue，LEAVE模拟break REPATE do…while 用ITERATE模拟continue，LEAVE模拟break WHILE while 用ITERATE模拟continue，LEAVE模拟break 游标游标使用的流程遵循：定义，OPEN，FETCH，CLOSE。语法如下 DECLARE cursor_name CURSOR FOR select_statementOPEN cursor_nameFETCH [[NEXT] FROM] cursor_name INTO var_name [, var_name] ...CLOSE cursor_name 条件处理程序执行过程中可能出现一些需要特殊处理的情况，比如继续执行还是推出程序？可以为一个条件定义处理器，条件也可以被命名。 命名条件使用DECLARE … CONDITION 语法，此步骤可选。 定义处理器使用DECLARE … HANDLER 语法 自己抛出一个条件使用SIGNAL 语法，定义条件处理器中继续抛出使用RESIGNAL 语法 获取错误内容使用 GET DIAGNOSTICS 语法 例子： -- 命名DECLARE division_by_zero CONDITION FOR SQLSTATE &apos;22012&apos;;-- 定义处理器以及使用RESINGAL DECLARE CONTINUE HANDLER FOR division_by_zero RESIGNAL SET MESSAGE_TEXT = &apos;Division by zero / Denominator cannot be zero&apos;; -- GET DIAGNOSTICS语法DROP TABLE test.no_such_table;-- ERROR 1051 (42S02): Unknown table &apos;test.no_such_table&apos;GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;SELECT @p1, @p2;+-------+------------------------------------+| @p1 | @p2 |+-------+------------------------------------+| 42S02 | Unknown table &apos;test.no_such_table&apos; |+-------+------------------------------------+ 常用的处理器： 常见问题有许多常见问题是因为MySQL本身的一些限制，可以参考：Restrictions on Stored Programs。下面记录一些常见的或者我碰到的问题，欢迎补充。 FETCH拿不到任何记录如果定义的变量名和SELECT的字段名一样，那么可能出现问题，这是MySQL的一个bug，解决方案是不要使变量名和字段名一样。 ERROR：Cursor declaration after handler declarationDECLARATION定义顺序错误，类似的还有Variable or condition declaration after cursor or handler declaration错误 参考资料https://dev.mysql.com/doc/refman/5.7/en/create-procedure.html http://chuiliu.github.io/2016/02/28/mysql%E7%9A%84definer%E5%92%8Cinvoker/ https://my.oschina.net/u/1424662/blog/485118 https://dev.mysql.com/doc/refman/5.7/en/sql-syntax-compound-statements.html http://www.yiibai.com/mysql/signal-resignal.html http://www.cnblogs.com/langtianya/p/5534222.html https://stackoverflow.com/questions/40661398/mysql-cursor-fetch-null","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"一个查询API引发的对前后端职责的思考","slug":"一个查询API引发的对前后端职责的思考","date":"2017-10-21T12:49:56.000Z","updated":"2017-10-29T02:36:02.260Z","comments":true,"path":"2017/10/21/一个查询API引发的对前后端职责的思考/","link":"","permalink":"http://yoursite.com/2017/10/21/一个查询API引发的对前后端职责的思考/","excerpt":"","text":"问题描述有一个在线博客系统，系统提供了一个API，前端只需要传递参数：(开始日期，结束日期)，然后就会返回一个这样的JSON:{日期1:新文章数量,日期2:新文章数量...}。现在来了一个新的需求：用户需要查看当天，本周，本月，最近半年或者一年新发布的文章的数量。现在需要设计后端API供前端调用，那么这个API应该如何设计呢？ 一开始，我想到了3种可能的方案： 直接使用之前的API，前端根据天，周，月等单位换算成时间区间，去后端查询出每天的新文章数量，然后在前端累加。 设计5个API，然后每个API处理不同的单位。 设计一个API，然后有一个枚举类型的参数表示5种不同的情况。 我的第一感觉是：方案1是最简单的，方案2看起来好像也可以，方案3感觉有点复杂了。我到底应该选择哪一种方案呢，每种方案的利弊是什么呢？ 方案一该方案很简单而且看起来很灵活，后端提供一个API，既可以用来获取每天新文章具体数目，又可以用来计算该区间内新总和，那么该方案有什么问题吗？ 我觉得这个方案最大的问题就是暴露了领域知识在前端，这里体现出来的就是前端人员需要计算本周的区间，本月的区间，本年的时间区间。当然这个知识很简单，前端人员肯定都知道怎么换算。但是这确实不应该由前端来处理，为什么呢？ 我个人觉得前端人员的职责主要就是单纯的调用后端的API，然后将数据展示出来。前端人员只需要知道哪些API是来干什么的以及调用的顺序即可。 单位的转换确实应该由后端完成。单位的概念也属于领域的知识，本例子中的年月日比较简单，但如果是(点，刻，字)这种时间单位呢？后端处理数据，数据的单位转换就应当交给后端完成。 举个详细的例子来说明由后端处理的好处：查询2017年9月的新文章数量。如果后端来做2017年9月的查询，那么就有这几种很好的实现： 换算成区间，然后使用之前API的代码查询并对结果求和，之后将结果缓存起来。 后端可以基于时间列创建日期列（如果数据库是MySQL可以使用Virtual columns），然后在日期列上创建索引。甚至查询结果也可以缓存起来。 方案二和方案三方案二和方案三都没有方案一的问题。之所以现在要将这两个放在一起说，是因为这两个的关系有点类似于面向对象设计里面的FlagArgument 问题。其建议不要提供一个唯一的API，然后通过额外的参数表示不同的行为，而是推荐提供多个表示不同行为的API。 Martin Fowler讨论FlagArgument时使用了下面的例子： // 1class Concert... public Booking book (Customer aCustomer, boolean isPremium) &#123;...&#125;//2class Concert... public Booking regularBook(Customer aCustomer) &#123;...&#125; public Booking premiumBook(Customer aCustomer) &#123;...&#125; 他给出了不要使用FlagArgument的主要原因： My reasoning here is that the separate methods communicate more clearly what my intention is when I make the call. Instead of having to remember the meaning of the flag variable when I see book(martin, false) I can easily read regularBook(martin). 从可读性和可维护性说起，假如regularBook的处理逻辑需要修改，那么第二种方式可以更好的定位到所有使用了reqularBook逻辑的地方，第一种方式则比较麻烦。但是这种情况并不是绝对的，在编程语言中的关键字参数或者枚举就可以绕过这个问题: 比如在Python中，我们可以使用关键字参数，调用方式大概如下ins.book(customer,isPremium=True) 使用或者使用枚举:ins.book(customer,PriceType.Premium) 现在讨论其扩展性，假如新增了一种价格类型，第一种方式需要将isPremium变成一个可以表示3种情况的枚举，而第二种方式则需要增加一个API，如果情况很多，那么第二种方式将会有大量的API产生。大量API主要会带来什么问题？我觉得主要看调用该API的人是谁，如果是后端自己用的API那么没什么问题，但是如果要给前端调用就有问题了：假如前端不关心价格类型。 举个例子：如果是第一种方式的API，后端需要告诉告诉前端：Hi Jay，我写了一个预定的API，到时候你传递用户编号和价格类型过来给我就可以了。如果是第二种方式则是：Hi Jay，我写了一系列用于预定的API，所有API你都需要传递用户编号过来，如果是XX价格类型，你就调用XXX API，如果是YY价格类型，你就调用YYY API，如果是…。 如果前端又需要关心价格类型，那么仍然可以采用第一种方式，因为访问后端的API时可以提供命名参数，如：book?price_type=premium。 因此在博客系统案例中，我最终选择了方案三，设计的API如下： GET /recent?range=1mrange值范围：1d 1w 1m 6m 1y... 参考资料https://softwareengineering.stackexchange.com/questions/359452/how-do-i-design-a-backend-api-with-a-different-query-range https://softwareengineering.stackexchange.com/questions/147977/is-it-wrong-to-use-a-boolean-parameter-to-determine-behavior https://martinfowler.com/bliki/FlagArgument.html","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://yoursite.com/categories/软件工程/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://yoursite.com/tags/软件工程/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"前后端分离","slug":"前后端分离","permalink":"http://yoursite.com/tags/前后端分离/"}]}]}